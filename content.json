{"meta":{"title":"Welcome to My Blog","subtitle":"by Palenew","description":"Palenew的博客","author":"Palenew","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-04-06T06:31:15.000Z","updated":"2017-04-06T06:31:15.760Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"微信内浏览器ajax会重复发送两次的bug","slug":"微信内浏览器ajax会重复发送两次的bug","date":"2017-04-20T03:48:09.000Z","updated":"2017-04-20T04:01:01.709Z","comments":true,"path":"2017/04/20/微信内浏览器ajax会重复发送两次的bug/","link":"","permalink":"http://yoursite.com/2017/04/20/微信内浏览器ajax会重复发送两次的bug/","excerpt":"","text":"最近工作参与了微信页面的开发，自己倒是没有遇到这个奇怪的bug，但是似乎很多人都被折磨过。 大概就是微信发送的ajax会被中转服务器转发，如果ajax的响应没有及时返回，时间过长，中转服务器就会放弃这次请求，然后直连的请求和中转的请求后端都接到了，然后后端就会奇怪为啥我接到两个ajax，而前端也很不解，我只发送了一个呀？ 然后我看到了一篇很棒的文章，作者文笔都可以做自媒体了，还干啥前端。 推荐文章： https://blog.fishlee.net/2016/07/07/double-request-from-wechat-client-with-ajax/","categories":[{"name":"微信开发","slug":"微信开发","permalink":"http://yoursite.com/categories/微信开发/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}],"keywords":[{"name":"微信开发","slug":"微信开发","permalink":"http://yoursite.com/categories/微信开发/"}]},{"title":"Unicode-控制字符","slug":"Unicode-控制字符","date":"2017-04-19T08:07:52.000Z","updated":"2017-04-19T08:25:54.424Z","comments":true,"path":"2017/04/19/Unicode-控制字符/","link":"","permalink":"http://yoursite.com/2017/04/19/Unicode-控制字符/","excerpt":"","text":"很久前就发现有个Q群好友的id在手机没有点开群，预览的时候是反着的。这两天有人问了下是加了“神秘代码”，去查了下，原来是Unicode-控制字符搞得鬼。 Unicode-控制字符 &amp;#8206;LRM‎ &amp;#8207;RLM &amp;#8205;ZWJ‍ &amp;#8204;ZWNJ‌ &amp;#8234;LRE‪ &amp;#8237;LRO‭ &amp;#8238;RLO &amp;#8236;PDF‬ &amp;#8302;NADS⁮ &amp;#8303;NODS⁯ &amp;#8299;ASS⁫ &amp;#8298;ISS⁪ &amp;#8301;AAFS⁭ &amp;#8300;IAFS⁬ &amp;#30;RS &amp;#31;US当然，也可以用16进制表示，如让文本实现反向排列的RLO对应的&#8238;等同于&#x202E;让前面运算法则结束的字符PDF是&#8236;等于&#x202C; Unicode-控制字符 解释 左到右标记 (LRM)操作时很象从左到右字符，只是它不显示。LRM 没有任何其它语义效果。 从右到左标记 (RLM)操作时很象从右到左字符，只是它不显示。RLM 没有任何其它语义效果。 零宽度联接器 (ZWJ)防止连续字符在输出上联接。 零宽度非联接器 (ZWNJ)在两个字符间添加非联接器，防止这两个字符在映射时连接草率。 启动从左到右的嵌套 (LRE)表示将从左到右嵌套一些文本。例如， 阿拉伯句子中间的英文引用语可被标记为从左到右的嵌套文本。（LRE 影响单词顺序，不影响字符顺序。） 启动从右到左的嵌套 (RLE)表示将从右到左嵌套一些文本。例如，英语引用语中间的希伯来短语可被标记为从右到左的嵌套文本。（RLE 影响单词顺序，不影响字符顺序。） 启动从左到右的优先 (LRO)当需要用于特殊情况（例如，用于部件编号）时，优先于双向字符类型。LRO 强制字符成为从左到右的字符。 启动从右到左的优先 (RLO)当需要用于特殊情况（例如，用于部件编号）时，优先于双向字符类型。RLO 强制字符成为从右到左的字符。 Pop 直接格式化 (PDF)终止上一个显式代码的效果（嵌套或优先），并将双向状态恢复到在上一个 LRE、RLE、RLO 或 LRO 控制字符之前的状态。 国家（地区）数字形状替代 (NADS)使用国家（地区）数字形状显示 U+0030-U+0039（ASCII 数字）。国家（地区）数字形状由当前用户的区域设置决定。 名义（欧洲）数字形状 (NODS)使用名义数字形状显示 U+0030-U+0039（ASCII 数字）。名义数字形状是欧洲数字。 激活对称交换 (ASS)表示是否应该将成对的字符名中的 LEFT 或 RIGHT 分别解释为有意义的打开或关闭。（默认状态是激活。） 禁止对称交换 (ISS)关闭象圆括号这样的字符的对称交换，这样其左边和右边能继续表明向左和向右的朝向， 与打开对称交换时的打开和关闭状态相反。 激活阿拉伯成形 (AAFS)控制阿拉伯兼容性字符的成形行为。在显示过程中，某些字母形式可能以草率的连接或者连字狐线的方式联接起来。成形选择器代码表示用于获得显示效果的字符形状确定（glyph 选择）过程是处于激活还是禁止状态。（默认状态为禁止。） 禁止阿拉伯成形 (IAFS)禁止字符成形确定过程， 这样字符不会根据位置而成形。 记录分隔符（块分隔符） (RS)在每个行分隔符后开始新的行。 US Unit Separator (Segment Separator)每个段分隔符后开始新的段。 拿去尝试装逼吧。【你可能需要先用记事本，把这个字符打出来，然后copy到QQ的昵称栏】","categories":[{"name":"tips小技巧","slug":"tips小技巧","permalink":"http://yoursite.com/categories/tips小技巧/"}],"tags":[{"name":"Unicode，控制字符","slug":"Unicode，控制字符","permalink":"http://yoursite.com/tags/Unicode，控制字符/"}],"keywords":[{"name":"tips小技巧","slug":"tips小技巧","permalink":"http://yoursite.com/categories/tips小技巧/"}]},{"title":"Git安装、使用","slug":"Git安装、使用","date":"2017-04-12T07:33:10.000Z","updated":"2017-04-12T07:58:32.101Z","comments":true,"path":"2017/04/12/Git安装、使用/","link":"","permalink":"http://yoursite.com/2017/04/12/Git安装、使用/","excerpt":"","text":"Git的安装 下载地址：https://git-for-windows.github.io/ 安装 安装之后，开始目录可以找到 git 文件夹，里面有个叫 git bash 的，那个就是 git 的命令窗口。 默认在资源管理器中右键也会有 Git GUI 和 Git Bash 选项。 git 的命令窗口初学者用起来并不舒服，所以还需要一个Tortoise git。https://tortoisegit.org/download/网页上还有汉化包，一同下载，顺序安装即可。安装后右键可以看到Tortoise git的三个命令。 或者也有很多其他的Git的管理工具，不如 SourceTree 。https://www.sourcetreeapp.com/ 设置ssh 设置Git的user name和email： 12$ git config --global user.name &quot;名称&quot;$ git config --global user.email &quot;邮箱&quot; 生成密钥 1$ ssh-keygen -t rsa -C &quot;邮箱&quot; 之后会要求你填写一些描述信息，可以都不填，回车。生成的密钥的位置在C:\\Users\\你的计算机用户名\\.ssh，其中的 id_rsa.pub ，公钥就是我们需要的。 设置密钥 git（如图位置–新建–将id_rsa.pub的内容复制进去） coding（类似git也是复制进去添加即可） 注意事项犹豫默认的Tortoise git会使用它默认的方式加密，并不会读取本地的刚才添加的ssh文件，所以Tortoise git也需要改一下设置。setting中对应图片改动下ssh采用的程序，改为git的ssh.exe 设置密钥就完成了，以后 pull（拉取）、push（推送）就不必输入账户密码，之间的通讯认证就自己完成了。 clone，将远程库的代码down下来 当远程库已经存在了，不论是 git 还是 coding 都提供一个 clone 地址。 获取到地址后，右键 Git Clone 命令，填入地址就可以把远程库中的文件down下来了了。 基础使用 pull commit push pull，拉取拉取命令是更新本地工作目录的代码，也就是把远程库最新的代码更新下来。在推送的时候要更新下远端代码再推送。 commit，提交不同于SVN，git除了工作库和远端库以外，还有缓存库，commit是把代码提交到了本地的缓存库中，并没有提交到远程库中。提交时必须填写日志文件，git默认不允许日志为空。commit时可以看到本地有改动的文件，双击可以看到详细的修改。 push，推送推送是把本地的代码推送到远端的库中，当远端版本比本地版本更高的时候会提示要先更新才允许推送。 分支 有关分支，待我大成再做阐述。","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"ssh","slug":"ssh","permalink":"http://yoursite.com/tags/ssh/"},{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/tags/版本控制/"},{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/分布式/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}]},{"title":"使用HTML5的drag方法的一个小demo","slug":"使用HTML5的drag方法的一个小demo","date":"2017-04-10T05:47:34.000Z","updated":"2017-04-12T08:04:11.049Z","comments":true,"path":"2017/04/10/使用HTML5的drag方法的一个小demo/","link":"","permalink":"http://yoursite.com/2017/04/10/使用HTML5的drag方法的一个小demo/","excerpt":"","text":"wait for edit","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"drag","slug":"drag","permalink":"http://yoursite.com/tags/drag/"},{"name":"draggable","slug":"draggable","permalink":"http://yoursite.com/tags/draggable/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}]},{"title":"webpack入门（二）","slug":"webpack入门（二）","date":"2017-04-06T08:37:10.000Z","updated":"2017-04-10T05:48:53.007Z","comments":true,"path":"2017/04/06/webpack入门（二）/","link":"","permalink":"http://yoursite.com/2017/04/06/webpack入门（二）/","excerpt":"","text":"webpack source mapsWebpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。 在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下： devtool选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度； cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项； cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； 配置到webpack.config.js中devtool: &apos;eval-source-map&apos;,//配置生成Source Maps，选择合适的选项 使用webpack构建本地服务器首先要安装依赖： npm install --save-dev webpack-dev-server devserver配置选项 功能描述 contentBase 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录） port 设置默认监听端口，如果省略，默认为”8080“ inline 设置为true，当源文件改变时会自动刷新页面 colors 设置为true，使终端输出的文件为彩色的 historyApiFallback 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html devServer: { contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录 colors: true,//终端中输出结果为彩色 historyApiFallback: true,//不跳转 inline: true//实时刷新 } Loadersmodule: { //在配置文件里添加JSON loader loaders: [ { test: /\\.json$/, loader: &quot;json&quot; } ] }, node.js语法相关// 这个js是index的实际js逻辑 var note = require( &apos;../note/vue_tab.md&apos; ); var $ = require(&apos;jquery&apos;); module.exports = function() { var temp = document.createElement(&apos;div&apos;); $(temp).css({&apos;max-width&apos;:&apos;1040px&apos;,&apos;margin&apos;:&apos;14px auto&apos;}); $(temp).append( &apos;&lt;p&gt;采用webpack加载的text_demo模块&lt;/p&gt;&apos; ); $(temp).append( require( &apos;../note/webpack_build.md&apos; ) ); $(temp).append( require( &apos;../note/webpack_extend.md&apos; ) ); $(temp).append( note ); return temp; }; 我可以按照规矩在模块中尽情使用require来引用别的模块（也就是文件）。需要注意的是，要在webpack.config.js中添加loaders支持文件格式。而第三方的插件，像是jq，只需要在npm中安装依赖，然后不需要写路径，直接引用。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}]},{"title":"webpack入门（一）","slug":"webpack入门（一）","date":"2017-04-06T08:37:02.000Z","updated":"2017-04-10T05:48:48.690Z","comments":true,"path":"2017/04/06/webpack入门（一）/","link":"","permalink":"http://yoursite.com/2017/04/06/webpack入门（一）/","excerpt":"","text":"安装1$ npm install webpack -g 确定已经有 package.json，没有就通过 npm init 创建安装 webpack 依赖（依赖安装后会down下来webpack到node_module中，并且packge.json中会对应添加依赖。）1$ npm install webpack --save-dev 如果需要使用 Webpack 开发工具，要单独安装：（为了可以直接执行webpack的打包命令）1$ npm install webpack-dev-server --save-dev 构建项目–简单地一个demomain.js123// 把text_demo模块的内容加载进来var text = require(&apos;./text_demo.js&apos;);document.getElementById(&apos;root&apos;).appendChild(text()); text_demo.js123456// 这个js只是返回一条字符串module.exports = function() &#123; var text = document.createElement(&apos;div&apos;); text.textContent = &quot;hello webpack！&quot;; return text;&#125;; 也就相当于index引用了bundle.js，而bundle.js的内容是由webpack打包生成的。页面的逻辑是在text_demo中，而main是webpack的入口，bundle.js是webpack打包地产物。 配置文件的加入（脱离复杂的命令行）（webpack.config.js）webpack.config.js1234567// 这里是webpack配置文件，使用它可以直接配置选项，脱离复杂的命令行module.exports = &#123;entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名&#125;&#125; 这样，只需要直接运行webpack就可以了。 还可以配置多个入口文件12345678910entry: &#123; index: __dirname + &quot;/app/js/index.js&quot;, demo1: __dirname + &quot;/app/js/demo1.js&quot;,&#125;,devtool: &apos;eval-source-map&apos;, //配置生成Source Maps，选择合适的选项output: &#123; path: __dirname + &quot;/public/js&quot;, //打包后的文件存放的地方 filename: &quot;[name].bundle.js&quot;, //打包后输出文件的文件名 // chunkFilename: &quot;[id].chunk.js&quot;&#125;, 在package.json中配置123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125; 这样还可以直接使用npm start命令来启用webpack打包。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-06T08:11:34.852Z","updated":"2017-04-06T02:56:56.174Z","comments":true,"path":"2017/04/06/hello-world/","link":"","permalink":"http://yoursite.com/2017/04/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"span中的input标签上面有几个小像素空隙","slug":"span中的input标签上面有几个小像素空隙","date":"2017-04-06T07:57:28.000Z","updated":"2017-04-19T08:27:59.821Z","comments":true,"path":"2017/04/06/span中的input标签上面有几个小像素空隙/","link":"","permalink":"http://yoursite.com/2017/04/06/span中的input标签上面有几个小像素空隙/","excerpt":"","text":"看公司之前的代码的时候，发现一个小bug，一个input的位置比希望的位置更加靠下了差不多3个像素，而span中又确实是只有一个input，input是被什么挤下去了这个一个小空间呢？ 产生原因原因是写代码都习惯是换行写下一层的标签，但是span中会把代码的这个换行也变成实际的页面内容展示出来，因此就相当于input前面有一个回车占了位置，input挤到下一行，上面多出一个空隙。 ###解决方法 不换行，input和span写到一行，但是这个方法并不实用，可能会让这一行变得非常的长。 可以给span添加 font-size:0;，input重新加 font-size 这样虽然还是有换行，但是没有占到位置。 如果不是去修改老代码，而是自己写的新代码，那么不要用 &lt;span&gt; 一个行内元素去包裹 &lt;input&gt; 这种块级元素。也省的以后出别的 bug 。","categories":[{"name":"tips小技巧","slug":"tips小技巧","permalink":"http://yoursite.com/categories/tips小技巧/"}],"tags":[{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"input标签","slug":"input标签","permalink":"http://yoursite.com/tags/input标签/"},{"name":"空隙","slug":"空隙","permalink":"http://yoursite.com/tags/空隙/"}],"keywords":[{"name":"tips小技巧","slug":"tips小技巧","permalink":"http://yoursite.com/categories/tips小技巧/"}]},{"title":"如何使用 hexo + git 创建自己的博客","slug":"如何使用-hexo-git-创建自己的博客","date":"2017-04-06T03:33:40.000Z","updated":"2017-04-06T04:14:39.384Z","comments":true,"path":"2017/04/06/如何使用-hexo-git-创建自己的博客/","link":"","permalink":"http://yoursite.com/2017/04/06/如何使用-hexo-git-创建自己的博客/","excerpt":"","text":"如何使用hexo和git创建并配置一个博客。你需要有一个github账户，一个name.github.io的仓储，有node.js的本地环境（npm包含在node中了）。 安装使用hexo。 npm install -g hexo 安装hexo hexo init 当前文件夹初始化一个hexo 启动服务 hexo g 生成html文件，放置在 public 中 hexo s 启动服务，localhost:4000 更换主题 搜索自己喜欢的主题 https://hexo.io/themes/ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载主题文件，会下载到themes文件夹中 修改 _config.yml 中的 theme 来修改主题 推送到git hexo d 上传至git 需要配置 _congfig.yml 中的 deploy 1234deploy: type: git repository: git@github.com:Palenew/Palenew.github.io.git branch: master 需要一个插件支持 hexo-deployer-git npm install hexo-deployer-git source文件夹 source文件夹中的文件，除了md文件，其他文件都会被原样推到git上 常见命令12345678hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo clean #清理 public 中的文件 缩写 123456hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deployhexo s -g #生成并本地预览hexo d -g #生成并上传 写博客hexo new &#39;my-first-blog&#39;会在_post文件夹中生成相关的md文件 .md 博客文章的格式 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 使用 &lt;!--more--&gt; 来分割前言和主体，这样首页显示会默认显示改标签之前的部分，而不会把整个文章显示出来。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}]}]}